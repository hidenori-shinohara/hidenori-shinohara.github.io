---
layout: post
title:  "FHE notes"
date:   2023-08-01
author: Hidenori
---

Notes from https://web.archive.org/web/20221207103926/https://blog.quarkslab.com/a-brief-survey-of-fully-homomorphic-encryption-computing-on-encrypted-data.html

# Limits of FHE

Data dependent branching is an extremely complex topic in FHE.
Consider this simple algorithm:

```
def f(flag, a ,b):
    if flag:
        return a
    else:
        return b
```

If `flag`, `a`, and `b` are all given in cypher texts, then I can't return the correct value as I won't be able to decipher `flag`.
One possible approach is to do a calculation like `flag * a + (1 - flag) * b` where `flag` is assumed to be either 0 or 1.
This gives a mathematically correct answer, but this is computationally different.

To make it more obvious, look at this example:

```
def f(flag, a ,b):
    if flag:
        return super_expensive_function_1(a)
    else:
        return super_expensive_function_2(b)
```

If we returned `flag * super_expensive_function_1(a) + (1 - flag) * super_expensive_function_2(b)`, we will likely perform both expensive functions.
However, conventional programming languages will evaluate only one of them.

Another example is a conditional loop.
It is not obvious at all how one could make a conditional loop possible work with FHE.

